<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 魏落阳城的博客</title>
    <link>https://leo-AJ.github.io/post/</link>
    <description>Recent content in Posts on 魏落阳城的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>版权为敖晋个人所有</copyright>
    <lastBuildDate>Fri, 03 Jan 2020 17:06:17 +0800</lastBuildDate>
    
	<atom:link href="https://leo-AJ.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>刷题 链表1（C语言）</title>
      <link>https://leo-AJ.github.io/post/%E5%88%B7%E9%A2%98-%E9%93%BE%E8%A1%A81c%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 03 Jan 2020 17:06:17 +0800</pubDate>
      
      <guid>https://leo-AJ.github.io/post/%E5%88%B7%E9%A2%98-%E9%93%BE%E8%A1%A81c%E8%AF%AD%E8%A8%80/</guid>
      <description>刷题-链表1（C语言） 题目描述： 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
解题思想  创建一个空链表 同时遍历两个链表将较小的插入到空链表后 当一个链表遍历结束后，将另一个链表剩下的部分全部插入到新建的链表后 删除头节点，返回链表地址  代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ struct ListNode* p; struct ListNode* q; p = (struct ListNode*)malloc(sizeof(struct ListNode));//创建空链表  q = p;//给工作指针赋值  while((l1 != NULL) &amp;amp;&amp;amp; (l2 != NULL) )//同时遍历两个链表  { if(l1-&amp;gt;val &amp;lt;= l2-&amp;gt;val) { q-&amp;gt;next = l1; l1 = l1-&amp;gt;next; }else{ q-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } q = q-&amp;gt;next;//千万不要忘记  } q-&amp;gt;next = (l1 !</description>
    </item>
    
    <item>
      <title>线性表的链式存储结构</title>
      <link>https://leo-AJ.github.io/post/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 02 Jan 2020 21:02:46 +0800</pubDate>
      
      <guid>https://leo-AJ.github.io/post/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>线性表的链式存储结构 先上代码： #ifndef _LIST_H_#define _LIST_H_ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;time.h&amp;gt; typedef int ElemType; typedef struct Node { ElemType data; struct Node* next; } Node; typedef struct Node* LinkList; void CreateListHead(LinkList *L,int n); int TraveList(LinkList L); int getElem(LinkList L,int i,ElemType* e); int ListInsert(LinkList* L,int i,ElemType e); int ListDelete(LinkList* L,int i,ElemType* e); int ClearList(LinkList* L); #endif // _LIST_H_  #include &amp;#34;list.h&amp;#34; void CreateListHead(LinkList* L,int n){ LinkList p; int i; *L = (LinkList)malloc(sizeof(Node)); (*L)-&amp;gt;next = NULL; srand(time(0));//初始化随机数种子  for(i = 0;i &amp;lt; n;i++){ p = (LinkList)malloc(sizeof(Node));//为新节点开辟空间  p-&amp;gt;data = rand()%100 + 1; p-&amp;gt;next = (*L)-&amp;gt;next; (*L)-&amp;gt;next = p; } } int TraveList(LinkList L) { int i = 0; LinkList p; p = L; while(p-&amp;gt;next) { i++; p=p-&amp;gt;next; printf(&amp;#34;the number is %d,the data is %d\n&amp;#34;,i,p-&amp;gt;data); } return i; } int getElem(LinkList L,int i,ElemType* e){ int j = 1; LinkList p; p = L-&amp;gt;next; while(p &amp;amp;&amp;amp; j&amp;lt;i) { p = p-&amp;gt;next; j++; } if(!</description>
    </item>
    
    <item>
      <title>线性表的顺序存储结构</title>
      <link>https://leo-AJ.github.io/post/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 01 Jan 2020 17:51:06 +0800</pubDate>
      
      <guid>https://leo-AJ.github.io/post/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>线性表的顺序存储结构 先上代码： #include &amp;#34;Sqlist.h&amp;#34;//各个函数的具体实现 int Init_SqList(SqList* L){ for(int i = 0;i &amp;lt; MAXSIZE;i++) L-&amp;gt;data[i] = 0; L-&amp;gt;length = 0; return 0; } int Get_Elem(SqList* L,int i,ElemType* e){ if(L-&amp;gt;length == 0 || i &amp;lt; 1 || (i &amp;gt; L-&amp;gt;length)) return -1; *e = L-&amp;gt;data[i-1]; return 0; } int Insert_Elem(SqList* L,int i,ElemType e){ int k = 0; if(L-&amp;gt;length == MAXSIZE) return -1; if((i &amp;gt; (L-&amp;gt;length) + 1) || i &amp;lt; 1) return -1; if(i &amp;lt;= L-&amp;gt;length){ for(k = L-&amp;gt;length -1;k &amp;gt;= i-1;k--) L-&amp;gt;data[k+1] = L-&amp;gt;data[k]; } L-&amp;gt;data[i-1] = e; L-&amp;gt;length++; return 0; } int Delete_Elem(SqList* L,int i,ElemType* e){ int k = 0; if(L-&amp;gt;length == 0) return -1; if((i &amp;gt; L-&amp;gt;length) || i &amp;lt; 1) return -1; *e = L-&amp;gt;data[i-1]; if(i &amp;lt; L-&amp;gt;length){ for(k = i;k &amp;lt; L-&amp;gt;length;k++) L-&amp;gt;data[k-1] = L-&amp;gt;data[k]; } L-&amp;gt;length--; return 0; } int Search_Elem(SqList* L,ElemType e){ int i = 0; if(L-&amp;gt;length == 0) return -1; for (i = 0;i &amp;lt; L-&amp;gt;length;i++){ if(e == L-&amp;gt;data[i]) return i+1; } return -1; } int Modify_Elem(SqList* L,int i,ElemType e){ if(L-&amp;gt;length == 0) return -1; if((i &amp;gt; L-&amp;gt;length) || i &amp;lt; 1) return -1; if(i &amp;lt; L-&amp;gt;length){ L-&amp;gt;data[i-1] = e; } return 0; } #ifndef __SQLIST_H_#define __SQLIST_H_ #define MAXSIZE 20typedef int ElemType; typedef struct{ ElemType data[MAXSIZE]; int length; } SqList; int Init_SqList(SqList* L); int Get_Elem(SqList* L,int i,ElemType* e); int Insert_Elem(SqList* L,int i,ElemType e); int Delete_Elem(SqList* L,int i,ElemType* e); int Search_Elem(SqList* L,ElemType e); int Modify_Elem(SqList* L,int i,ElemType e); #endif // __SQLIST_H_  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>在win10环境下d基于hugo搭建个人博客</title>
      <link>https://leo-AJ.github.io/post/%E5%9C%A8win10%E7%8E%AF%E5%A2%83%E4%B8%8Bd%E5%9F%BA%E4%BA%8Ehugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 29 Dec 2019 10:01:45 +0800</pubDate>
      
      <guid>https://leo-AJ.github.io/post/%E5%9C%A8win10%E7%8E%AF%E5%A2%83%E4%B8%8Bd%E5%9F%BA%E4%BA%8Ehugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>在win10环境下基于Hugo搭建个人博客 准备工作  注册Github账号  最终的文件要放到远程仓库里托管，让其他人可访问。 具体注册过程自行百度，注册完成后，新建仓库。注：仓库名一定要是:你的注册用户名.github.io   下载安装Git与Hugo  Git的下载网址：https://git-scm.com/downloads Git的安装与配置网上有很多教程，这里就不在赘述。 Hugo的下载网址：https://github.com/gohugoio/hugo/releases 在win10的环境下选择“hugo_0.57.2_Windows-64bit.zip”的版本，下载下来是一个直接可以运行的.exe文件，当然你下载的具体版本号可能不同。 Hugo下载好后，一定要把文件路径添加到环境变量中，具体方法自行百度。 若在下载过程中出现，下载速度巨慢或者连接失败，可以找找淘宝的镜像，当然还有我的百度云连接奉上：https://pan.baidu.com/s/18QaW5rWaErmxecpluhQoXQ	提取码：4mvr    开始搭建博客   打开windows的“命令提示符”（Win + R，输入cmd）。
  进入你想要的路径，开始新建本地站点
d: cd github hugo new site blog 进入D盘的github目录下就可以看到一个blog文件夹（为该站点的根目录），进入该文件夹，里面有若干子文件。
  下载主题：进入https://themes.gohugo.io/挑选一个自己喜欢的主题，进入之后里面具体的安装配置方法。安装好主题后，在blog文件夹下的themes文件夹下有主题的文件，文件名一般为该主题的主题名。在这里吐槽一下，要看懂安装说明还是需要一定的英文水平，我就在网上找了一个大神的，copy下来自己该了改，但是我没有学过前端，照猫画虎修改了几处，效果就是你们现在看到的样子。
  在本地启动，看看主题效果
hugo server -t 主题名 --buildDrafts 若成功，则在最下面一行可以找到 http://localhost:1313/ 的本地浏览网址，复制下来在浏览器里打开就可以看到博客的样子了，当然现在里面还没有一篇博文。
  编写自己的博客
hugo new post/搭建博客.md 执行这条命令后，就会在blog\content\post文件夹下生成搭建博客.md的文件，接下来就可以进行编辑你的博客了，推荐用Typora进行编写，因为太好用了，哈哈哈。
  再次输入步骤四的命令，打开http://localhost:1313/ ，就可以在本地打开，看到你刚刚写的第一篇博文了。
  生成静态网站有关文件
hugo --theme=主题名 --baseUrl=&amp;quot;https://账号名.github.io/&amp;quot; --buildDrafts 执行这条命令后，就会在blog\public\文件夹下生成有关文件</description>
    </item>
    
  </channel>
</rss>